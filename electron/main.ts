import { app, BrowserWindow, ipcMain, globalShortcut } from 'electron';
import * as path from 'path';
import { spawn, ChildProcess } from 'child_process';

// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require('electron-squirrel-startup')) {
  app.quit();
}

let pythonProcess: ChildProcess | null = null;
const pendingRequests: Map<string, { resolve: (value: any) => void, reject: (reason: any) => void }> = new Map();
let messageBuffer: Buffer = Buffer.alloc(0);
let expectedLength: number | null = null;
let backendRunning = false;

async function startBackend() {
  let executablePath: string;
  
  if (app.isPackaged) { // production
    executablePath = path.join(process.resourcesPath, 'app');
    if (process.platform === 'win32') {
      executablePath += '.exe';
    }
  } else { // development
    executablePath = path.join(__dirname, '..', '..', 'backend', 'dist', 'app');
    if (process.platform === 'win32') {
      executablePath += '.exe';
    }
  }
  
  console.log('Starting PyInstaller IPC backend at:', executablePath);

  // Start Python executable process directly (no need for 'python' command)
  pythonProcess = spawn(executablePath, [], {
    stdio: ['pipe', 'pipe', 'pipe']
  });

  // Handle Python process output
  if (pythonProcess.stdout) {
    pythonProcess.stdout.on('data', (data: Buffer) => {
      handlePythonData(data);
    });
  }

  if (pythonProcess.stderr) {
    pythonProcess.stderr.on('data', (data: Buffer) => {
      console.error(`Python stderr: ${data.toString()}`);
    });
  }

  pythonProcess.on('close', (code: number) => {
    console.log(`Python process exited with code ${code}`);
  });

  pythonProcess.on('error', (error: Error) => {
    console.error('Failed to start Python process:', error);
  });

  // Test the connection
  try {
    const pingResult = await sendToPython({ command: 'ping' });
    console.log('Python IPC connection established:', pingResult);
    return true;
  } catch (error) {
    console.error('Failed to establish Python IPC connection:', error);
    return false;
  }
}

function handlePythonData(data: Buffer) {
  // Append new data to buffer
  messageBuffer = Buffer.concat([messageBuffer, data]);
  
  // Process all complete messages in buffer
  while (messageBuffer.length > 0) {
    // If we don't know the expected length yet, and we have at least 4 bytes
    if (expectedLength === null && messageBuffer.length >= 4) {
      // Read the first 4 bytes to get the message length
      expectedLength = messageBuffer.readUInt32LE(0);
      // Remove the length bytes from the buffer
      messageBuffer = messageBuffer.slice(4);
    }
    
    // If we know the expected length and have enough data
    if (expectedLength !== null && messageBuffer.length >= expectedLength) {
      // Extract the message
      const messageData = messageBuffer.slice(0, expectedLength);
      // Remove the message from the buffer
      messageBuffer = messageBuffer.slice(expectedLength);
      
      // Parse and process the message
      try {
        const message = JSON.parse(messageData.toString('utf8'));
        const requestId = message.requestId;
        
        if (requestId && pendingRequests.has(requestId)) {
          const { resolve } = pendingRequests.get(requestId)!;
          pendingRequests.delete(requestId);
          resolve(message);
        } else {
          console.warn('Received response with unknown request ID:', requestId);
        }
      } catch (error) {
        console.error('Error parsing message from Python:', error);
      }
      
      // Reset for the next message
      expectedLength = null;
    } else {
      // Not enough data for a complete message
      break;
    }
  }
}

function sendToPython(message: any): Promise<any> {
  return new Promise((resolve, reject) => {
    if (!pythonProcess || !pythonProcess.stdin) {
      reject(new Error('Python process not running'));
      return;
    }
    
    // Add request ID to track responses
    const requestId = Date.now().toString() + Math.random().toString(36).substring(2, 5);
    message.requestId = requestId;
    
    // Store callback in pending requests
    pendingRequests.set(requestId, { resolve, reject });
    
    // Convert message to JSON string
    const messageStr = JSON.stringify(message);
    const messageBuffer = Buffer.from(messageStr, 'utf8');
    
    // Write message length (4 bytes) followed by message
    const lengthBuffer = Buffer.alloc(4);
    lengthBuffer.writeUInt32LE(messageBuffer.length, 0);
    
    pythonProcess.stdin.write(lengthBuffer);
    pythonProcess.stdin.write(messageBuffer);
  });
}

// Setup IPC handlers to communicate with renderer process
function setupIPC() {
  ipcMain.handle('run-simulation', async (event, circuitData) => {
    try {
      return await sendToPython({
        command: 'run_simulation',
        data: circuitData
      });
    } catch (error) {
      console.error('Error in run-simulation IPC handler:', error);
      return {
        success: false,
        error: error.message || 'Unknown error'
      };
    }
  });
  ipcMain.handle('get-backend-status', () => backendRunning);
}

const createWindow = (): void => {
  console.log('Creating window');
  const mainWindow = new BrowserWindow({
    height: 600,
    width: 1000,
    webPreferences: {
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
      contextIsolation: true,
      nodeIntegration: false,
      devTools: !app.isPackaged,
      spellcheck: false,

    },
    autoHideMenuBar: true
  });
  mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);
};

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
app.on('ready', async () => {
  setupIPC();
  const backendStarted = await startBackend();
  backendRunning = backendStarted !== false;
  const allWindows = BrowserWindow.getAllWindows();
  if (allWindows.length === 0) {
    createWindow();
  }

  if (backendRunning !== false) {
    // Let renderer know backend is ready
    setTimeout(() => {
      const win = BrowserWindow.getAllWindows()[0];
      win?.webContents.send('backend-ready', true);
    }, 100); // slight delay ensures renderer is listening
  } else {
    console.error('Python backend failed to start');
    const win = BrowserWindow.getAllWindows()[0];
    win?.webContents.send('backend-ready', false);
  }
});

// Disable reloading of window with Ctrl + R when packaged
app.on('browser-window-focus', function () {
  if(app.isPackaged) {
    globalShortcut.register("CommandOrControl+R", () => {
      console.log("CommandOrControl+R is pressed: Shortcut Disabled");
    });
    globalShortcut.register("F5", () => {
      console.log("F5 is pressed: Shortcut Disabled");
    });

  }
});
app.on('browser-window-blur', function () {
  if(app.isPackaged) {
    globalShortcut.unregister('CommandOrControl+R');
    globalShortcut.unregister('F5');
  }
});

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on('window-all-closed', () => {
  app.quit();
  if (pythonProcess) {
    pythonProcess.kill();
  }
});

app.on('activate', () => {
  // On OS X it's common to re-create a window in the app when the
  // dock icon is clicked and there are no other windows open.
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow();
  }
});

app.on('quit', () => {
  if (pythonProcess) {
    pythonProcess.kill();
  }
});